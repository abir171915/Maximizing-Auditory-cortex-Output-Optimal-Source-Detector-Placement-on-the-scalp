% Suppose you have already added NIRFASTer to Matlab path
clear
% load the mesh
mesh = load_mesh('slab_stnd');
% We can have a look
figure,plot3dmesh(mesh, mesh.region);hold on
scatter3(mesh.source.coord(:,1), mesh.source.coord(:,2), mesh.source.coord(:,3), 50, 'ro', 'filled');
scatter3(mesh.meas.coord(:,1), mesh.meas.coord(:,2), mesh.meas.coord(:,3), 50, 'bs', 'filled');

%displaying number of sources and detectors
num_sources = size(mesh.source.coord, 1);
num_detectors = size(mesh.meas.coord, 1);
%displaying coords of sources and detectors
disp('Coordinates of the sources:');
disp(mesh.source.coord);
disp('Coordinates of the detectors:');
disp(mesh.meas.coord);

%changing the source coords and detectors coords
new_source_coords = [
    -0.0087, 86.7231, 29.2425;
    -0.0035, 87.7446, 23.3764;
    -0.0128, 87.003, 16.3047;
    -0.0052, 87.8018, 9.3137;
    -0.0242, 62.2346, 31.1464;
    -0.0016, 61.5719, 24.1539;
    -0.0104, 62.121, 19.4558;
    -0.0076, 62.2356, 11.1127
];
new_detector_coords = [
    -0.0011, 99.2206, 27.012;
    -0.0138, 101.032, 19.1787;
    -0.0109, 99.8071, 11.9208;
    -0.0109, 74.6267, 27.8799;
    -0.0286, 75.8521, 19.1535;
    -0.0030, 75.4475, 11.4507;
    0.0357, 51.4966, 29.4162;
    0.0190, 51.4399, 22.1882;
    -0.0209, 52.0996, 14.3993
];

% Check if the new coordinates match the number of sources and detectors
if size(new_source_coords, 1) == num_sources && size(new_source_coords, 2) == 3
    % Update source coordinates
    mesh.source.coord = new_source_coords;
else
    error('The number of new source coordinates does not match the number of sources.');
end

if size(new_detector_coords, 1) == num_detectors && size(new_detector_coords, 2) == 3
    % Update detector coordinates
    mesh.meas.coord = new_detector_coords;
else
    error('The number of new detector coordinates does not match the number of detectors.');
end
% Display updated coordinates to verify
disp('Updated coordinates of the sources:');
disp(mesh.source.coord);

disp('Updated coordinates of the detectors:');
disp(mesh.meas.coord);

figure, plot3dmesh(mesh, mesh.region); hold on
scatter3(mesh.source.coord(:,1), mesh.source.coord(:,2), mesh.source.coord(:,3), 50, 'ro', 'filled');
scatter3(mesh.meas.coord(:,1), mesh.meas.coord(:,2), mesh.meas.coord(:,3), 50, 'bs', 'filled');

% We see this is a slab model with two layers
% Red circles are the sources, and blue squares are the detectors

% We can caculate the fluence generated by the sources
data = femdata_stnd_FD(mesh, 0);
% where 0 means the modulation frequency is 0, i.e. this is continuous wave
% The fluence information is now in field phi. Each column corresponds to a
% source

% Let's have a look at the result at source 2, in log scale
figure,plot3dmesh(mesh, log(data.phi(:,2)), 'x>50'); hold on
scatter3(mesh.source.coord(2,1), mesh.source.coord(2,2), mesh.source.coord(2,3), 50, 'ro', 'filled');

% We can also calculate the Jacobian: this represents the sensitivity of a
% pair of source-detector to regions in the medium, i.e. the banana
J = jacobian_stnd_FD(mesh, 0);
% again, 0 means continuous wave. THe pairing between sources and detectors
% is represented in mesh.link

% Let's have a look at (1,9). i.e. pair 9
figure,plot3dmesh(mesh, log(abs(J.complete(8,:))'),'x+y>120'); hold on
scatter3(mesh.source.coord(1,1), mesh.source.coord(1,2), mesh.source.coord(1,3), 50, 'ro', 'filled');
scatter3(mesh.meas.coord(9,1), mesh.meas.coord(9,2), mesh.meas.coord(9,3), 50, 'bs', 'filled');

% We can assume there's an anomaly/inclusion in the slab, whose absorptino
% is 10% higher than baseline
center = [60,60,35];
radius = 5;
idx = vecnorm(mesh.nodes - center, 2, 2) < radius; %identifying the anomaly nodes
mesh2 = mesh;
mesh2.mua(idx) = mesh.mua(idx) * 1.1; %absorption cooef increased for the anomaly nodes 10%
% this is important
mesh2.kappa = 1./(3*(mesh2.mua + mesh2.mus)); %for the diffusion cooeff
% Have a look
figure,plot3dmesh(mesh2, mesh2.mua, 'x>60'); hold on

% Now imagine we have some measurement on this slab with anomaly, and would
% like to recontruct its location based on the measurement
% This is the simulated measurement
data2 = femdata_stnd_FD(mesh2, 0);
% In linear approximation of DOT, we have 
% \Delta Log(data)=Jacobian * \Delta mua
% where \Delta means in comparison to baseline

% Two things:
% In CW-DOT we can only reconstruct \Delta mua 
% Baseline in \Delta Log(data) is assumed known, usually estimated as time
% average of recording in real-life data

% A naive solution
d_mua = pinv(J.complete) * log(data2.amplitude ./ data.amplitude);
figure,plot3dmesh(mesh2, d_mua, 'x>60'); hold on

% This is a terrible idea: results can oscillate quite badly, esp when
% there is noise. It's usually better to use l2 regularization
d_mua_better = tikhonov(J.complete, 10, log(data2.amplitude ./ data.amplitude));
figure,plot3dmesh(mesh2, d_mua_better, 'x>60'); hold on

% The difference is more obvious when data is noisy
noisydata = data2.amplitude + 1e-7*randn(size(data2.amplitude));
noisydata(noisydata<0) = 1e-20;     % amplitude should never be negative
d_mua = pinv(J.complete) * log(noisydata ./ data.amplitude);
figure,plot3dmesh(mesh2, d_mua, 'x>60'); hold on

d_mua_better = tikhonov(J.complete, 10, log(noisydata ./ data.amplitude));
figure,plot3dmesh(mesh2, d_mua_better, 'x>60'); hold on

% We can also see the difficulty of doing DOT: even a small amount of noise
% can worsen the results quite substantially
